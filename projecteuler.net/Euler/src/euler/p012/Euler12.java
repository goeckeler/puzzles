package euler.p012;

import static euler.utils.Utils.divisors;
import static euler.utils.Utils.primeFactors;
import static java.math.BigInteger.ONE;

import java.math.BigInteger;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import euler.primes.Factors;
import euler.primes.Sieve;
import euler.utils.SubSet;

/**
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 +
 * 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 * 
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * 
 * Let us list the factors of the first seven triangle numbers:
 * 
 * <pre>
 *        1: 1
 *        3: 1,3
 *        6: 1,2,3,6
 *       10: 1,2,5,10
 *       15: 1,3,5,15
 *       21: 1,3,7,21
 *       28: 1,2,4,7,14,28
 * </pre>
 * 
 * We can see that 28 is the first triangle number to have over five divisors.
 * 
 * What is the value of the first triangle number to have over five hundred divisors?
 */
public class Euler12
{
  public static Set<BigInteger> triangles = null;

  public static void main(String[] args) {
    playWithFactors();
    // playWithSinglePrimes();
    // playWithTriplePrimes();
  }

  public static void playWithFactors() {
    int times = 1000;
    int base = 12000;
    long maxDivisors = 1;
    long endDivisors = 500;
    long upper = triangle(base + times + 1);
    System.out.println("Generating factors for " + upper + " at " + new Date() + ".");
    Factors factors = new Factors(upper);
    System.out.println("Factoring triangle numbers at " + new Date() + ".");
    for (int n = 0; n < times; ++n) {
      long triangle = triangle(base + n);
      List<Long> primes = factors.primeFactors(triangle);
      long divisors = factors.divisors();
      
      if (divisors > maxDivisors) {
        maxDivisors = divisors;
        System.out.println("> triangle(" + (base + n) + ") = " + triangle + " has " + divisors + " divisors => " + primes.toString());
        
        if (divisors >= endDivisors) break; 
      }
      
      if ((n + 1) % 1000 == 0) {
        System.out.println(". triangle(" + (base + n) + ") = " + triangle + " has " + divisors + " divisors => " + primes.toString());
      }
    }
  }

  public static boolean isTriangle(BigInteger integer) {
    if (triangles == null) {
      // generate triangles
      triangles = new TreeSet<BigInteger>();
      for (long n = 1; n < 100000; ++n) {
        triangles.add(triangleB(n));
      }
    }

    return triangles.contains(integer);
  }

  public static void playWithTriplePrimes() {
    // 4 primes^3 and a single prime make 512 divisors
    // use only the first fifty primes
    Sieve primer = new Sieve(50);

    SubSet<Long> sets = new SubSet<Long>(primer.list(), 5);
    BigInteger smallest = BigInteger.valueOf(Long.MAX_VALUE);
    long smallestN = -1L;

    List<Set<Long>> factors = sets.list();
    System.out.println("Determing triple solution\n");
    for (Set<Long> solution : factors) {
      // check if correct
      System.out.print("Prime factors " + solution.toString());
      BigInteger product = BigInteger.ONE;
      BigInteger highest = BigInteger.ONE;
      for (Long prime : solution) {
        BigInteger value = BigInteger.valueOf(prime);
        if (value.compareTo(highest) > 0) {
          highest = value;
        }
        product = product.multiply(value).multiply(value).multiply(value);
      }
      // last one is only a single one
      product = product.divide(highest).divide(highest);

      System.out.print(" = " + product + " is ");

      if (isTriangle(product)) {
        System.out.println("triangle !");
        if (product.compareTo(smallest) < 0) {
          smallest = product;
        }
      } else {
        System.out.println("not triangle");
      }
    }

    if (smallest.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0) {
      System.out.println("\nFound triangle " + smallest + " for n=" + smallestN);
    } else {
      System.out.println("\nNo matching triangle found.");
    }
  }

  public static void playWithSinglePrimes() {
    // 9 primes make 512 divisors
    // use only the first fifty primes
    Sieve primer = new Sieve(50);

    SubSet<Long> sets = new SubSet<Long>(primer.list(), 9);
    check(sets.list());
  }

  public static void check(List<Set<Long>> factors) {
    BigInteger smallest = BigInteger.valueOf(Long.MAX_VALUE);
    System.out.println("Determing solution\n");
    for (Set<Long> solution : factors) {
      // check if correct
      System.out.print("Prime factors " + solution.toString());

      BigInteger product = BigInteger.ONE;
      BigInteger highest = BigInteger.ONE;
      for (Long prime : solution) {
        BigInteger value = BigInteger.valueOf(prime);
        if (value.compareTo(highest) > 0) {
          highest = value;
        }
        product = product.multiply(value);
      }

      System.out.print(" = " + product + " is ");

      if (isTriangle(product)) {
        System.out.println("triangle !");
        if (product.compareTo(smallest) < 0) {
          smallest = product;
        }
      } else {
        System.out.println("not triangle");
      }
    }

    if (smallest.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0) {
      System.out.println("\nFound triangle " + smallest + ".");
    } else {
      System.out.println("\nNo matching triangle found.");
    }
  }

  public static void solve(List<Integer> primes, Set<Integer> solution) {
    if (solution.size() == 9) {
      // check if correct
      System.out.print("Prime factors " + solution.toString());
      long product = 1;
      for (Integer prime : solution) {
        product *= prime;
      }
      System.out.print(" = " + product + " is ");

      long n = Math.round((Math.sqrt(1 + 8 * product) - 1) / 2);
      long triangle = triangle(n);

      if (triangle == product) {
        System.out.println(" triangle of " + n);
        System.exit(0);
      }

      System.out.println(" not triangle of " + n + " which is " + triangle);
      return;
    }

    solution.add(primes.get(0));
    for (int index = 1; index < primes.size(); ++index) {
      solve(primes.subList(index, primes.size()), solution);
    }
    solution.remove(primes.get(0));
  }

  public static void testMe() {
    // smallest number with five primes square
    long number = 1 * 2 * 2 * 3 * 3 * 5 * 5 * 7 * 7 * 11 * 11;
    System.out.println("Five primes is " + number + " has " + divisors(number) + " divisors.");
    number *= 2;
    System.out.println("Five primes and a two is " + number + " has " + divisors(number) + " divisors.");
    number /= 2;
    // added a single prime
    number *= 13;
    System.out.println("Five primes and a single is " + number + " has " + divisors(number) + " divisors.");
    number *= 2;
    System.out.println("Five primes and a two plus single is " + number + " has " + divisors(number) + " divisors.");
    number /= 2;
    // smallest number with six primes square
    // number *= 13;
    // System.out.println("Six primes is " + number + " has " + divisors(number) + " divisors.");
    number = 1 * 2 * 2 * 2 * 2 * 3 * 3 * 5 * 5 * 7 * 7 * 11 * 11;
    System.out.println("Five primes and a squared two is " + number + " has " + divisors(number) + " divisors.");
  }

  public static void bruteForce() {
    long min = 1; // 7390;
    long max = 100; // Math.round(Math.sqrt(Long.MAX_VALUE) / Math.sqrt(2)) - 1;
    long divisors = 500;
    long current = 0;
    long triangle = 0;
    long n = min;

    long largestD = 0;
    // brute force
    do {
      triangle = triangle(n);
      current = divisors(triangle);
      if (max < 1000) dump(n, triangle, current);

      if (current > largestD) {
        largestD = current;
        dump(n, triangle, current);
      }
      ++n;
    } while (current <= divisors && n <= max);
    System.out.println("Triangle(" + (n - 1) + ") = " + triangle + " has " + current + " divisors > " + divisors +
                       " divisors.");
  }

  public static void dump(long n, long triangle, long divisors) {
    StringBuilder text = new StringBuilder();
    text.append("t(").append(n).append(") = ");
    text.append(triangle).append(", ").append(divisors);
    text.append(" divisors. p(").append(n).append(") = ").append(primeFactors(n));
    text.append(", p(").append(triangle).append(") = ").append(primeFactors(triangle));
    System.out.println(text.toString());
  }

  public static long triangle(long n) {
    return n * (n + 1) / 2;
  }

  public static BigInteger triangleB(long n) {
    BigInteger num = BigInteger.valueOf(n);
    BigInteger triangle = num.multiply(ONE.add(num)).divide(BigInteger.valueOf(2));
    return triangle;
  }
}
